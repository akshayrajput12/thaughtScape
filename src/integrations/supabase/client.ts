
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://oxnbnaznhubhqfjyllms.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im94bmJuYXpuaHViaHFmanlsbG1zIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzU2MzM3NDMsImV4cCI6MjA1MTIwOTc0M30.BxJB2-7bMCHZhgby4HudUTnTrvRwjECWFixDPjnmGwg";

// Initialize Supabase client with improved auth options
export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true
    }
  }
);

// Export a function to check if a user's email is confirmed
export const isEmailConfirmed = async (userId: string) => {
  try {
    const { data, error } = await supabase
      .from('profiles')
      .select('id')
      .eq('id', userId)
      .single();
    
    if (error) {
      console.error("Error checking email confirmation:", error);
      return false;
    }
    
    return !!data;
  } catch (err) {
    console.error("Error in isEmailConfirmed:", err);
    return false;
  }
};

// Check if an email already exists in the database
export const checkEmailExists = async (email: string) => {
  try {
    // Instead of using admin.listUsers which isn't available in the client,
    // we'll check if we can sign up with this email
    const { data, error } = await supabase.auth.signInWithOtp({
      email: email,
      options: {
        shouldCreateUser: false // We don't want to create a user, just check if it exists
      }
    });
    
    // If there's no error when trying to send OTP to a non-existing email,
    // then the email doesn't exist
    if (!error) {
      return false;
    }
    
    // If we get an error about user not found, the email doesn't exist
    if (error.message.includes("Email not found") || 
        error.message.includes("User not found")) {
      return false;
    }
    
    // For other errors, assume the email exists
    return true;
  } catch (err) {
    console.error("Error in checkEmailExists:", err);
    return false;
  }
};

// Block a user
export const blockUser = async (blockedId: string) => {
  try {
    const { data: session } = await supabase.auth.getSession();
    if (!session?.session?.user.id) return { success: false, error: 'Not authenticated' };
    
    const blockerId = session.session.user.id;
    
    const { error } = await supabase
      .from('blocked_users')
      .insert({ blocker_id: blockerId, blocked_id: blockedId });
    
    if (error) {
      console.error("Error blocking user:", error);
      return { success: false, error: error.message };
    }
    
    return { success: true };
  } catch (err) {
    console.error("Error in blockUser:", err);
    return { success: false, error: 'Unknown error occurred' };
  }
};

// Unblock a user
export const unblockUser = async (blockedId: string) => {
  try {
    const { data: session } = await supabase.auth.getSession();
    if (!session?.session?.user.id) return { success: false, error: 'Not authenticated' };
    
    const blockerId = session.session.user.id;
    
    const { error } = await supabase
      .from('blocked_users')
      .delete()
      .eq('blocker_id', blockerId)
      .eq('blocked_id', blockedId);
    
    if (error) {
      console.error("Error unblocking user:", error);
      return { success: false, error: error.message };
    }
    
    return { success: true };
  } catch (err) {
    console.error("Error in unblockUser:", err);
    return { success: false, error: 'Unknown error occurred' };
  }
};

// Check if a user is blocked
export const isUserBlocked = async (userId: string) => {
  try {
    const { data: session } = await supabase.auth.getSession();
    if (!session?.session?.user.id) return false;
    
    const blockerId = session.session.user.id;
    
    const { data, error } = await supabase
      .from('blocked_users')
      .select('id')
      .eq('blocker_id', blockerId)
      .eq('blocked_id', userId)
      .maybeSingle();
    
    if (error) {
      console.error("Error checking if user is blocked:", error);
      return false;
    }
    
    return !!data;
  } catch (err) {
    console.error("Error in isUserBlocked:", err);
    return false;
  }
};

// Check if current user is blocked by target user
export const isBlockedBy = async (userId: string) => {
  try {
    const { data: session } = await supabase.auth.getSession();
    if (!session?.session?.user.id) return false;
    
    const currentUserId = session.session.user.id;
    
    const { data, error } = await supabase
      .from('blocked_users')
      .select('id')
      .eq('blocker_id', userId)
      .eq('blocked_id', currentUserId)
      .maybeSingle();
    
    if (error) {
      console.error("Error checking if blocked by user:", error);
      return false;
    }
    
    return !!data;
  } catch (err) {
    console.error("Error in isBlockedBy:", err);
    return false;
  }
};
